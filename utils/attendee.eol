import "table.eol";

operation Attendee neighbors(): Set {
	if (self.seat == null) {
		return Set{};
	}
	var seats = self.seat.table.seats;
	var length = seats.size();
	var index = seats.indexOf(self.seat);
	
	var nextIndex = index + 1;
	if (nextIndex == length) { 
		nextIndex = 0;
	}
	
	var previousIndex = index - 1;
	if (previousIndex == -1) {
		previousIndex = length - 1;
	}
	
	var nextPerson = seats.at(nextIndex).attendee;
	var previousPerson = seats.at(previousIndex).attendee;
	
	var neighbors : Set;
	if (nextPerson <> null) neighbors.add(nextPerson);
	if (previousPerson <> null) neighbors.add(previousPerson);
	
	return neighbors.excluding(self);
}

operation Attendee nameAndLocation(): String {
	var location = self.seat.table.identifier;
	var name = self.name;
	return self.name + " at " + location;
}

operation Attendee allocateSeat(): Boolean {
	// get all seats which are not allocated and sorts them so that the seats with most number of attendees
	// nearby are first
	var available = Seat.all.select(s|s.attendee == null).sortBy(s|s.table.attendees().size());
	var originalSeat = self.seat; // store self's copy so that if the search fails, we restore the initial state.
	
	for (seat in available) {
		self.seat = seat;
		if (self.neighborsSpeakCommonLanguage()) {
			return true;
		}
	}
	
	self.seat = originalSeat;
	return false;
}

operation Attendee neighborsSpeakCommonLanguage() : Boolean {
	// Get all the languages of the neighbors into a single list, 
	// and check if at least one of the is spoken by the current attendee.
	// Note the list of languages is not unique, but it does not matter.
	return self.neighbors().languages.flatten().exists(l|self.languages.contains(l));
}